\documentclass{bfh}
\usepackage[numbers]{natbib}
\usepackage[nohyperlinks]{acronym}

\title{Bachelor Thesis}
\subtitle{An Android Client for Bitmessage}
\author{Christian Basler}
\advisor{Kai Brünnler}
\expert{Daniel Voisard}
\date{\today}

\newcommand{\abbr}[1]{\textbf{#1}}

\begin{document}
  \maketitle

  \tableofcontents

  \newpage
  \section*{Abstract}

  Even if we use encryption, we reveal a lot about ourselves in the metadata we produce. Bitmessage prevents this by distributing a message in a way that it's not possible to find out which was the intended recipient.
  
  This thesis aims to develop an Android client for the Bitmessage protocol.
  
  \section*{Abbreviations}
  \begin{acronym}[Bash]
    \acro{POW}    {Proof of Work}
    \acro{PGP}    {Pretty Goot Privacy}
    \acro{MIME}   {Multipurpose Internet Mail Extensions}
    \acro{S/MIME} {Secure/\acs{MIME}}
    \acro{JDBC}   {Java Database Connectivity}
    \acro{API}    {Application Programming Interface}
    \acro{DOS}    {Denial of Service}
  \end{acronym}

  \newpage

  \section{Introduction}

  \subsection{What is Metadata?}

  While encryption technology like \ac{PGP} or \acs{S/MIME} provides a secure way to protect content from prying eyes, ever since the revelations of whistle-blower Edward Snowden we learned that metadata --- most notably information about who communicates with whom --- is equally interesting and much easier to analyse.\cite{guardian:metadata}

  \subsection{How Can We Hide Metadata?}

  With e-mail, all metadata is plain text, even for encrypted messages. We might be able to encrypt the connection to the e-mail provider, and they might or might not encrypt their connections to other providers. We can only hope that both our and the recipient's e-mail provider are both trustworthy and competent. Can we really expect that from something we get for free?

  With Bitmessage we send a message to a sufficiently large number of participants, with the intended recipient among them. Content is encrypted such that only the person in possession of the private key can decrypt it. All participants try to do this in order to find their messages.

  \subsection{What is Bitmessage}
  
  Bitmessage is a peer to peer protocol building a mesh network among the participating clients. Every client tries to maintain multiple connections and has a full copy of every current object.
  
  Objects are encrypted using a public key. Every client tries to decrypt each object using its private keys, processing the ones where it succeeds.
  
  A big advantage of Bitmessage is its inherent key management. The address contains a hash of the public key, and retrieving said key is part of the protocol.

  \subsubsection{Structure of a Bitmessage Object}
  Objects are distributed throughout the network.

  \includegraphics[width=\textwidth]{images/object.pdf}

  To prevent malicious flooding of the network and, to a lesser extent, spam, a nonce needs to be found such that a specific hash over the whole object represents a number lower than a calculated threshold. This is called \ac{POW}.

  The object header consists of the expiration time, object type and version, stream number and the actual payload. (Streams ar an optimisation feature of the protocol, so it stays somewhat scalable if many people start using Bitmessage.)
  
  The payload contains the actual data, depending on the message type.
  
  The signature covers everything except the nonce and is encrypted along with the payload, thus covering the unencrypted payload.
  
  Note: public keys of older addresses are an exception as they aren't encrypted.

(TODO)\newpage

  \subsection{Current state -- why is it bad?}
  Until recently there was no mobile client for Bitmessage, and the client that turned up since is very wasteful to the devices resources, draining the battery in little time. The alternative is to use an e-mail relay server, but this means to give up the private key to this server and end-to-end encryption is much more difficult to achieve. Therefore this might not be a viable option, especially if you can't run your own server.

  \subsection{How should it be?}
  We need mobile Bitmessage clients that allows the user to choose their levels of convenience, privacy and resource hunger. There will always be trade-offs between needed traffic, battery use and privacy, and for each user the answer might look slightly different.

  \subsection{Why is it hard to do?}
  Bitmessage is very wasteful with resources by design. All messages are being sent to and stored on all nodes, and to protect the network \ac{POW} is required for all objects that are distributed. The protocol wasn't developed with mobile users in mind, and while smartphones are getting increasingly powerful, there is at least the issue of battery use to watch out for, and most users have limited traffic on their data plan.

  \subsection{Why me, and how do I intend to do it?}
  I have seven years of experience developing Java applications, and was programming Android apps from the moment I had my ``Android Dev Phone 1''. As I developed Jabit, a Java implementation of the Bitmessage client, as my last project, I also have great knowledge about the Bitmessage protocol.

  There are a few optimisations that I intend to do:
  \begin{itemize}
    \item Connect to only one reliable node instead of eight random nodes. This should reduce battery usage, but yields some risk if the node is compromised. Also, the node must forward all messages to all connected mobile clients instead of the default eight random nodes.
    \item Don't save objects we can't decrypt. We can solely save their hashes, but this means we're using the network without supporting it. This also might be an attack vector.
    \item Only connect to the network if we're on Wi-Fi and charging. This means of course that we'll only receive messages when we're connected with a Wi-Fi and charging.
  \end{itemize}
  Of course every option has its own drawbacks, so they will be configurable. As for the \ac{POW}: Jabit highly optimises its calculation, which might be enough for modern smartphones.

  Further optimisations might introduce a server component that might do
  \begin{itemize}
    \item \acl{POW}
    \item Request public keys, requiring us to give up some anonymity towards the server.
    \item Inform the client about new messages sent to its addresses. This would mean to give up our anonymity towards the server in the best case (which isn't supported by the protocol yet), towards the whole network (which is somewhat supported), or give up the private key to the server (which, for many users, is unacceptable).
  \end{itemize}

  \subsection{Jabit Architecture}
  Jabit follows the Ports and Adapters architecture. There is a domain module which contains all the data types and most parts of the protocol implementation, and provides several ports, to which adapters can be attached. Adapters include the data repositories, network code and, more recently, cryptography (see \ref{subsec:bcvssc} \nameref{subsec:bcvssc}{}).

  \begin{center}
    \includegraphics[width=0.5 \textwidth]{images/ports_and_adapters.pdf}
  \end{center}

  \section{Naive Implementation}
  
  The naive implementation attempts to use the Jabit Bitmessage library as it is, with as little mobile optimisations as possible.

  \subsection{Unexpected Problems}
  Most problems can be summarised as this: Android builds on the Java language, but not on the Java platform.
  
  \subsubsection{Bouncy Castle vs. Spongy Castle}
  \label{subsec:bcvssc}
  Jabit heavily relies on Bouncy Castle, a very popular encryption library.\cite{bouncy} Unfortunately, Android ships with a broken version of Bouncy Castle. Even worse, when building an Android app the toolchain just discards any Bouncy Castle dependencies in favour of the built-in, broken version.

  Some people recognised this problem, and built a fork of Bouncy Castle, called Spongy Castle. It basically just replaces “Bouncy” with “Spongy” wherever necessary, so it doesn’t get discarded during the build process. This works fine and is quite easily done. Unfortunately, this doesn’t work on the Desktop.

  The Oracle JVM requires Security Providers to be signed, which is done for Bouncy Castle builds, but not so for the Spongy derivation. As forking Jabit wasn’t an option, the whole Security part had to be refactored in an exchangeable module, and implemented twice, in both a bouncy and a spongy manifestation.

  \subsubsection{JDBC}
  Android has its own API to access the included SQLite database. While it’s a nice, easy to use \ac{API}, the Android team didn’t deem it necessary to support \ac{JDBC}, which is the Java standard API to connect to databases.

  There is an open source project attempting to implement a \ac{JDBC} driver for Android’s SQLite database called SQLDroid,\footnote{\url{https://github.com/SQLDroid/SQLDroid}} which looked very promising. Unfortunately, it lacks essential features, such as returning the automatically generated key of an inserted row. Even worse, it doesn't have the courtesy of throwing a NotImplementedException for missing features, instead it just does nothing and returns null where a result is required, making debugging unnecessarily complicated.

  Unfortunately, discovering SQLDroid was unfit for the job took more time than reimplementing all repositories using the Android database API. As they were already implemented as adapters, no change was necessary on the Jabit library. Some changes were made in the futile attempt to use JDBC though, most of them only to be reverted later on.

  \subsection{Expected Problems}
  Those problems were to be expected and need to be fixed as part of this thesis.

  \subsubsection{\acl{POW}}
  Although modern smartphones tend to have faster processors than cheap personal computers, \ac{POW} for sending a public key takes around 15 minutes on a device with four cores at 2.5 GHz. Even worse, during this time it uses so much power that the device discharges even when connected to a power supply.

  \section{Android Specific Challenges}
  \subsection{Application Lifecycle}
  As with any good mobile system, Android doesn't hesitate to end all threads of an application running in background, in order to save resources. Consequently anything that should be kept alive -- network connections and \ac{POW} come to mind -- need special treatment. This is done through foreground services. The networking part and \ac{POW} hence needed to be moved into separate services. While not difficult, it needed some research to find out how it should best be done in our case.

  \begin{center}
    \includegraphics[width=0.6 \textwidth]{images/services.pdf}
  \end{center}

  \section{Optimisations}
  \subsection{Sync Adapters}
  Android provides an API that can vastly reduce battery usage for apps that regularly update data over the internet. The system triggers synchronisation, so it can optimise its sleep modes. Imagine otherwise, 15 apps synchronising every 15 minutes, one after the other. The device would never sleep.

  Although it's not intended, synchronisation can be done within the Bitmessage protocol without any modifications. What is needed is a trusted node that's always available and therefore best run on a proper server. On successful connection all new messages are being exchanged, so we just need to connect, wait until new messages were exchanged, and then disconnect.

  As Jabit is a Java library, it was trivial to create a server application using Spring Boot and Jabit. It turned out though that it's necessary to limit the number of connections in a Bitmessage server, therefore connections are now being severed after 12 hours or when a limit of 100 connections is reached.

  \subsection{Server Side \acl{POW}}
  To reduce power consumption and possibly reduce the time to send a message, \ac{POW} can be calculated by the synchronisation server. This feature needs some changes on both server and client, but only minor tweaks in the protocol.
  
  \subsubsection{Basic Idea}
  The server accepts messages without \ac{POW}, which it then will compute and fill in, and then relay that message. Of course this would leave the server extremely vulnerable to \ac{DOS} attacks -- an attacker could just send a bunch of messages and the server would be busy the rest of its life.
  
  We need some sort of authentication.

  \subsubsection{Protocol Tweaks}
  Fortunately, Bitmessage has very secure authentication built in: every message is signed by a private key. We'll just send a message to the server that contains the actual message as content. All nonce fields are set to zero. Ther server checks if the sender is on a white list and then calculates the nonce and relays the complete message.

  \newpage
  \bibliographystyle{plain}
  \bibliography{bibliography}

\end{document}