\documentclass{bfh}
\usepackage[numbers]{natbib}
\usepackage[nohyperlinks]{acronym}
\usepackage[labelformat=empty]{caption}
\usepackage[rightcaption]{sidecap}
\usepackage{float}
\usepackage{pdflscape}

\title{Bachelor Thesis}
\subtitle{An Android Client for Bitmessage}
\author{Christian Basler}
\advisor{Dr Kai Brünnler}
\expert{Daniel Voisard}
\date{\today}

\newcommand{\abbr}[1]{\textbf{#1}}

\begin{document}
  \lstset{language=Java}
  \maketitle

  \section*{Trademarks}
  Android and Google Play are trademarks of Google Inc.\\
  Oracle and Java are registered trademarks of Oracle and/or its affiliates.\\
  Other names may be trademarks of their respective owners.

  \section*{Abbreviations}
  \begin{acronym}[S/MIME ]
    \acro{POW}    {proof of work}
    \acro{CPU}    {central processing unit}
    \acro{GPU}    {graphics processing unit}
    \acro{VM}     {virtual machine}
    \acro{OS}     {operating system}
    \acro{PGP}    {Pretty Good Privacy}
    \acro{MIME}   {multipurpose internet mail extensions}
    \acro{S/MIME} {Secure/\acs{MIME}}
    \acro{JDBC}   {Java database connectivity}
    \acro{SQL}    {structured query language}
    \acro{NoSQL}  {Not only \acs{SQL}}
    \acro{API}    {application programming interface}
    \acro{DOS}    {denial of service}
    \acro{nonce}  {number used once}
    \acro{IP}     {internet protocol}
    \acro{REST}   {representational state transfer}
  \end{acronym}


  \newpage
  \section*{Abstract}
  Even if you are encrypting your e-mails, you still can't hide who you're writing to. Your e-mail client might even reveal much more about you, your computer, and the software you use.

  Bitmessage solves all this, but up until now there was no practical way to use it on mobile phones. That's where this thesis comes in.


  Bitmessage is a peer to peer messaging protocol that builds a mesh network among the participating clients. Each client tries to maintain multiple connections to other network nodes and has an encrypted copy of every current message.

  There are some unique challenges for mobile clients. For one, its users are very privacy conscious. Also, the protocol needs both huge amounts of traffic and a lot of \acs{CPU} time.

  It works by distributing every message to every client, so they can pick up the ones they can decrypt with the available private keys.

  To protect the network from malicious flooding, clients must find a partial hash collision as \acl{POW} in order to send a message. This is designed to be relatively slow even on desktop computers.

  So typically you'd want as many \acs{CPU} cores as possible, no shortage of power and a flat rate on internet access – a challenge for a mobile app.

  Android\texttrademark{} has some challenges, too. To preserve resources, the \acl{OS} might kill any process at any time, especially those in the background that process incoming network objects. Then there are some major Java dependencies missing in the Android \acs{VM}, most notably \acs{JDBC}, used to access databases. And finally, the devices differ vastly in processing power. The implementation we propose solves these problems.

  In addition there were two optional optimisations that require a server. First, Android provides a highly optimized method to synchronize data with a server, which we leveraged while still using the official Bitmessage protocol. Secondly, an option to let a server do the \acl{POW} was added for weaker phones. For both options the user must give up some of his anonymity towards the server --- the choice is theirs.

  You can get more information about the app at \url{https://dissem.ch/abit}

  \begin{center}
    \includegraphics[width=0.2 \textwidth]{images/QR_abit_webpage.pdf}
  \end{center}


  \newpage
  \tableofcontents


  \newpage
  \section{Introduction}

  \subsection{What is Metadata?}

  Metadata is information about data we create or access. This could be the websites we visit, what television programmes we watch, or with whom we communicate. The volume and quality of metadata greatly depends on the kind of data and the software that created it.

  While encryption technology like \ac{PGP} or \acs{S/MIME} provides a secure way to protect content from prying eyes, it can't hide the header information of an e-mail: sender, recipient, subject and possibly much more.

  Ever since the revelations of whistleblower Edward Snowden we learned that metadata --- most notably information about who communicates with whom --- is equally interesting and much easier to analyse than the actual content.\cite{guardian:metadata}

  \subsection{How Can We Hide Metadata?}

  With e-mail, all metadata is plain text, even for encrypted messages. We might be able to encrypt the connection to the e-mail provider, and they might or might not encrypt their connections to other providers. We can only hope that both our and the recipient's e-mail provider are both trustworthy and competent. Can we really expect that from something we get for free? And can we be sure they're not forced to release what they know to some agency?\cite{yale:nsl}

  \subsection{What is Bitmessage}
  
  With Bitmessage we send a message to a sufficiently large number of participants, among them the intended recipient. Content is encrypted such that only the person in possession of the private key can decrypt it. All participants try to do this in order to find their messages.

  It is a peer to peer protocol building a mesh network among the participating clients. Every client tries to maintain multiple connections to other network nodes and has a full copy of every current object.
  
  Objects are encrypted using a public key. Every client tries to decrypt each object using its private keys, processing the ones where it succeeds.

  Other that Bitcoin, Bitmessage does not have a block chain. This is a common misconception, as those protocols otherwise share many of their ideas.

  \subsubsection{Advantages}
  A big advantage of Bitmessage is its inherent key management. The address contains a hash of the public key, and retrieving said key is an integral part of the protocol.

  And the selling point of course is that everything is encrypted and signed, and there is next to no metadata an attacker could use.

  Finally, the setup is very easy. You just need to install a client software, there's no setup necessary except a click to create a new identity (i.e. Bitmessage address) if your client didn't do that when it started for the first time.

  \subsubsection{Disadvantages}
  Of course the protocol uses a lot of resources. The traffic problem could be somewhat managed by splitting it into streams\cite{wiki:stream}, but \acf{POW}, an expensive operation, is required in order to protect the network.

  As you might guess, the protocol doesn't scale well. As the user base grows and traffic increases, it might be too much for weaker clients (read mobile phones) to process. Again, streams are said to be the solution, but if there's a big surge in network usage the implementations might not be ready. Unfortunately for this project, a successful mobile client could cause such a surge.

  If somehow your private key gets into wrong hands, they can read every message you ever received, even if you deleted them locally. Nobody can prevent an entity from collecting all encrypted objects just in case they might be of value someday. They can't read the messages you've \textit{sent} though, unless they got your recipient's private key as well.

  On the usability side, the addresses aren't really human readable, and any method to make it look friendlier would most probably be either complicated to set up or make the client insecure, or both. Then most clients do not yet support attachments, and there's still some controversy on how to implement them into the protocol. Large attachments wouldn't be possible anyway, due to message size restrictions and \ac{POW}.

  \subsubsection{Risks}
  As when you decide to use Tor, a software for enabling anonymous communication formerly known as `The Onion Router', you could be flagged by some security agency as a potential threat.\cite{wired:tor} By itself this isn't necessarily a problem, but if you're a journalist it might put your informants at risk, and combined with other red flags it's possible you are prevented from flying in or into the U.S.A.


  \subsection{Motivation behind this Thesis}
  \subsubsection{Current state -- what is missing?}
  Until recently there was no mobile client for Bitmessage, and the client that turned up since is very wasteful to the devices resources, draining the battery in little time. The alternative is to use an e-mail relay server, but this means to give up the private key to this server and end-to-end encryption is much more difficult to achieve. Therefore this might not be a viable option, especially if you can't run your own server.

  \subsubsection{How should it be?}
  We need mobile Bitmessage clients that allow the user to choose their levels of convenience, privacy and resource hunger. There will always be trade-offs between needed traffic, battery use and privacy, and for each user the answer might look slightly different.

  \subsubsection{Why is it hard to do?}
  Bitmessage is very wasteful with resources by design. All nodes receive and store all messages, and to protect the network \ac{POW} is required for all objects that are distributed, meaning some very \acs{CPU}-heavy calculations need to be done. The protocol wasn't developed with mobile users in mind, and while smartphones are getting increasingly powerful, there is at least the issue of battery use to watch out for, and many users have a limited data plan.

  \subsubsection{Why me, and how do I intend to do it?}
  I have seven years of experience developing Java applications, and was programming Android apps from the moment I had my ``Android Dev Phone 1''. As I developed Jabit, a Java implementation of the Bitmessage client, as my last project, I also have acquired extensive knowledge about the Bitmessage protocol.

  There are a few optimisations that I intend to do:
  \begin{itemize}
    \item Connect to only one reliable node instead of eight random nodes. This should reduce battery usage, but yields some risk if the node is compromised. Also, the node must forward all messages to all connected mobile clients instead of the default eight random nodes.
    \item Don't save objects we can't decrypt. We can solely save their hashes, but this means we're using the network without supporting it. This also might be an attack vector.
    \item Only connect to the network if we're on Wi-Fi and charging. This means of course that we'll only receive messages when we're connected with a Wi-Fi and charging.
  \end{itemize}
  Of course every option has its own drawbacks, so they will be configurable. As for the \ac{POW}: Jabit highly optimises its calculation, which might be enough for modern smartphones.

  Further optimisations might introduce a server component that \textit{might} do
  \begin{itemize}
    \item Proof of work
    \item Request public keys, requiring us to give up some anonymity towards the server.
    \item Inform the client about new messages sent to its addresses. This would mean to give up our anonymity towards the server in the best case (which isn't supported by the protocol yet), towards the whole network (which is somewhat supported), or give up the private key to the server (which, for many users, is unacceptable).
  \end{itemize}

  To find out what is actually necessary, a naive implementation without optimisations will be done first.

  \subsection{The Jabit Bitmessage Library}
  The source code for Jabit is available at \url{https://github.com/Dissem/Jabit}

  Jabit has been developed as a preparing project for this thesis. It implements (most of) the Bitmessage protocol in Java and can therefore easily be used both for server applications as well as Android apps.

  Almost all other clients are based on PyBitmessage, which is somewhat inconvenient as it always requires PyBitmessage to run along with the client. This isn't really a problem on desktop computers, but might render creating  an easily deployable server application slightly more difficult, and is quite impractical on mobile devices.


  \subsubsection{Architecture}
  Jabit uses the Ports and Adapters pattern, also known as Hexagonal Architecture. This pattern isolates the core application from external dependencies. This vastly facilitates testing, as we can easily replace every dependency with mocks.

  To achieve this isolation, we use adapters that encapsulate all necessary logic to communicate with an external dependency, e.g. a database. They communicate with the application via interfaces defined in the core module.

  The core module contains all the data types and most parts of the protocol implementation. Ports and corresponding adapter implementations exist for data repositories, \ac{POW}, network code and, more recently, cryptography (see \ref{subsec:bcvssc} \nameref{subsec:bcvssc}{}).

  \begin{center}
    \includegraphics[width=0.6 \textwidth]{images/ports_and_adapters.pdf}
  \end{center}

  While there was hope to reuse the \acs{JDBC} implementation of the \textit{repositories}, it was clear that at some point someone might want to use a \acs{NoSQL} database or some other means of storage. Unfortunately, an Android specific implementation came first, as explained in section \ref{subsec:jdbc} \nameref{subsec:jdbc}.

  The \textit{\acl{POW}} adapter exists in a single- and a multithreading version. The first mainly exists to show the concept, while the second one currently is always used to do the calculation, albeit remotely on a server or wrapped in some Android compatibility code. A future implementation that uses the \acs{GPU}, which sometimes have thousands of cores, might be magnitudes faster and could easily replace the current worker.

  The \textit{network} code was put in an adapter as some Android specific tweaks were expected. This turned out to be wrong, but it didn't slow down development and might facilitate a future rewrite of the network code, so it still seems to be a good decision.

  The \textit{cryptography} adapter is a fine example why you should never rely on static helper classes. Rewriting the code to use an adapter was a pain and it wouldn't have been complicated to do it right the first time.

  Adapter interfaces are all defined in package \texttt{ch.dissem.bitmessage.ports}.


  \newpage
  \section{The Bitmessage Protocol}

  \subsection{Bitmessage Commands}

  Commands are messages between nodes, used to initialize a connection and exchange information about the network and available objects.

  \includegraphics[width=\textwidth]{images/command.pdf}

  The \textbf{magic} is a number to mark the beginning of a command. It is always \texttt{0xE9BEB4D9}, but \textit{could} be changed for test clients so they can't connect to the real network.

  A \textbf{command} defines how the payload looks like and what the node is supposed to do with it. The commands used by the Bitmessage protocol are \textit{version}, \textit{verack}, \textit{addr}, \textit{inv}, \textit{getdata} and \textit{object}. Their uses are specified in the Bitmessage Protocol Specification.\cite{wiki:protocol}

  \textbf{Size} defines how many bytes of payload need to be read.

  The \textbf{checksum} is used to discover transmission errors.

  \textbf{Payload} is the data that belongs to a command. It could be anything from empty to a complex object containing a message.


  \subsection{Bitmessage Objects}
  Objects are distributed throughout the network using the ``object'' command. With exception of some legacy objects, they are signed and encrypted.

  \includegraphics[width=\textwidth]{images/object.pdf}

  To prevent malicious flooding of the network and, to a lesser extent, spam, a \textbf{nonce} needs to be found such that a specific hash over the whole object represents a number lower than a calculated threshold. This is called \acf{POW}, and described in detail in section \ref{subsec:pow}.

  The object \textbf{header} consists of the expiration time, type and version of the object, and stream number. (Streams are an optimisation feature of the protocol, so it should stay usable if many people start using Bitmessage.)
  
  The \textbf{payload} contains the actual data, depending on the message type.
  
  The \textbf{signature} covers everything except the nonce and is encrypted along with the payload, thus covering the unencrypted payload.

  There are four different types of objects in the Bitmessage protocol: \textit{getpubkey} is used to request a public key to some address, \textit{pubkey} contains said public key, \textit{msg} is a typical person-to-person message, and \textit{broadcast} is a message that is broadcast to anyone who subscribed to the sending address --- which needs to be known in order to subscribe.


  \subsection{Encryption}
  \label{subsec:encryption}
  Bitmessage uses elliptic curve cryptography for both signing and encryption. The math behind it is rather complicated, yet bases on the established principle to use a mathematical operation that has an inverse that is magnitudes more complicated than the operation itself. Instead of the typically used huge prime numbers, a point on an elliptic curve is multiplied by a high number.

  Advantages of elliptic curves are the fact that we don't need to search for big primes, but also that the keys can be much smaller while having the same encryption strength.

  Addition on the curve means finding the point where the line through those points intersects with the curve, and then find its reflection on the x-axis. If you add a point to itself, you use the tangent instead. In the example, $G$ is multiplied by 3 by first adding $G+G$ and then $2G+G$, resulting in point $3G$.

  \begin{center}
    \includegraphics[width=0.5 \textwidth]{images/multiplication_on_elliptic_curve.pdf}
  \end{center}

  Obviously you can't find a line from just one point, so there is no way to calculate $P \over 3$, and $P \over G$ can only be found by searching all options, assuming $P = G n$, which holds true in elliptic curve cryptography.

  In the following example, key pairs are represented by pairs of the same letter, lower case for the private key, and uppercase for public keys. This corresponds to the convention of using lowercase letters for scalars and uppercase letters for points.

  The user, let's call her Alice, needs a key pair, consisting of a private key
$$k$$
which represents a huge random number, and a public key
$$K = G k$$
which represents a point on the agreed on curve -- by default that's \textit{secp256k1} for Bitmessage. Please note that this is not a simple multiplication, but the multiplication of a point along an elliptic curve. $G$ is the starting point for all operations on a specific curve.

  Another user, Bob, knows the public key. To encrypt a message, Bob creates a temporary key pair with private key
$$r$$
and public key
$$R = G r$$
He then calculates
$$K r$$
uses the resulting point to encrypt the message by calculating a double SHA-512 hash over the x-coordinate and sends $K$ along with the message.

  When Alice receives the message, she uses the fact that
$$K r = G k r = G r k = R k$$
so she just uses $R k$ to decrypt the message.

  The exact method used in Bitmessage is called Elliptic Curve Integrated Encryption Scheme or ECIES, which is described in detail on Wikipedia.\cite{wikipedia:EC}\cite{wikipedia:ECC}\cite{wikipedia:ECIES}

  \subsection{Proof of Work}
  \label{subsec:pow}
  While invented as an anti-spam feature, Bitmessage uses \acf{POW} mainly to protect the network. Users can demand higher \ac{POW} for their identities as additional protection.

  If not for \ac{POW}, any malicious party could overload the network with an immense amount of messages, preventing other messages from being distributed and filling the hard disks of the weaker nodes, practically disabling the whole network. Therefore an object is only distributed to other nodes if its proof of work is correct and its time to live isn't up.

  The difficulty is calculated through a linear function of message size and time to live, i.e. a long lived message or a large one is more expensive to send, in terms of computation time.
$$ d = \frac{2^{64}}{n (l + \frac{t l}{2^{16}})} $$
\begin{tabular}{@{}>{$}l<{$}l@{}}
	d & target difficulty \\
	n & number of trials per byte \\
	l & payload length + extra byte \\
	t & time to live in seconds \\
\end{tabular}

  The virtual \textit{extra bytes}, currently at least 1000, prevent flooding the network with a great number of extremely small objects by adding some minimal difficulty that's necessary to send a message.

  \textit{Time to live} can be up to 28 days, which is the default for \textit{pubkey} objects, but for normal messages two days are commonly used.

  As \acl{POW}, the client must find a \acs{nonce} such that the first eight bytes of the object's hash (including \acs{nonce}) represent a smaller number than the target difficulty $d$.\\

  Note that the following pseudo code is optimised for readability. In a production implementation the loop should be as optimised (for speed) as possible, as it will be run so many times every nanosecond counts. Object creation and expensive conversions should carefully be avoided.

\begin{lstlisting}
byte[] nonce = new byte[8]

do {
    nonce++
} while (
    lt(
      target,
      SHA512(SHA512(nonce + initialHash))
    )
);
\end{lstlisting}

  \listinginfo{}{initialHash}{a single SHA-512 hash over the whole object except for the nonce}{}
  \listinginfo{}{lt(a, b)}{a helper method that takes the first eight bytes of both arrays and returns \texttt{true} if the ones from $a$ represent a smaller number than the ones from $b$ and \texttt{false} otherwise}{}
  \listinginfo{}{+}{in this context, a concatenation of both arrays}{[1, 2] + [3, 4] = [1, 2, 3, 4]}
  \listinginfo{}{++}{an increment by one, treating the array as a number}{[1, 255]++ == [2, 0]}


  \newpage
  \section{Naive Implementation}
  
  The naive implementation attempts to use the Jabit Bitmessage library as it is, with as little mobile optimisations as possible. The plan was to either discard or improve it afterwards. Fortunately, improvement was possible.

  \subsection{Unexpected Problems}
  Most problems can be summarised as this: Android builds on the Java language, but not on the Java platform. While the programming language is the same and most libraries can be used without any restrictions, there are some subtle differences that make a programmer's life hard --- some due to the limited resources of a mobile handset, others due to design decisions made by the Android development team.
  
  \subsubsection{Bouncy Castle vs. Spongy Castle}
  \label{subsec:bcvssc}
  Jabit heavily relies on Bouncy Castle, a very popular open source encryption library.\cite{bouncy} Sadly, Android ships with a broken version of Bouncy Castle. Even worse, when building an Android app, the toolchain just discards any Bouncy Castle dependencies in favour of the built-in, broken version.

  Roberto Tyley recognised this problem and built a fork of Bouncy Castle, called Spongy Castle.\cite{spongy} It basically just replaces “Bouncy” with “Spongy” wherever necessary, so it doesn’t get discarded during the build process. This works fine and is quite easily done. Unfortunately, it doesn’t work on the desktop: the Oracle JVM requires Security Providers to be signed, which is done for Bouncy Castle builds, but not so for the Spongy derivation.

  As forking Jabit wasn’t an option, the whole cryptography part had to be refactored into an exchangeable module and implemented twice, in both a bouncy and a spongy manifestation.

  \subsubsection{JDBC}
  \label{subsec:jdbc}
  Android has its own \ac{API} to access the included SQLite database. While it’s a nice, easy to use \ac{API}, the Android team didn’t deem it necessary to support \acs{JDBC}, which is the Java standard API to connect to databases.

  There is an open source project attempting to implement a \ac{JDBC} driver for Android’s SQLite database called SQLDroid, which looked very promising. But as it turned out, it lacks essential features, such as returning the automatically generated key of an inserted row. It doesn't even have the courtesy of throwing a NotImplementedException for missing features, instead it just doesn't do anything and returns \textit{null} where a result is required, making debugging unnecessarily tedious.\cite{github:sqldroid}

  Discovering SQLDroid was unfit for the job finally took more time than reimplementing all repositories using the Android database API. As the necessary ports already existed, the Jabit library could be left unchanged. Yet the futile attempt to use JDBC caused many adjustments, most of them only to be reverted later on.

  \subsection{Expected Problems}
  There were a few problems we actually expected. They need to be examined and possibly fixed as part of this thesis.

  \subsubsection{Proof of Work}
  Although modern smartphones tend to have faster processors than cheap personal computers, \acf{POW} for sending a public key takes more than 15 minutes on a device with four cores at 2.5 GHz. Even worse, during this time it uses so much power that the device discharges even when connected to a power supply.

  But as it used the default time to live of 28 days, cutting it down to two days shortened that time to a much more acceptable 1-2 minutes. Weaker devices still want to rely on a server to do their \ac{POW}, but for more privacy conscious people and those with stronger devices it is a viable option to do it on the mobile.

  \subsubsection{Data Traffic}
  Not creating a full node that also distributes the objects it receives certainly reduces the necessary internet traffic, but a Bitmessage client still needs to download around 1 GiB of incoming objects each month.

  The relatively crude solution to this problem is an option to prevent connecting to the mobile network.

  \begin{center}
    \includegraphics[width=0.8 \textwidth]{images/screenshots/wifi_only_setting.png}
  \end{center}

  \subsubsection{Storage}
  Limited storage isn't as big a problem as initially expected, experience showed that just barely over 100 MiB is used, which isn't a problem on current smartphones.

  It shouldn't be too difficult to implement an option not to store any object data we don't need, but it certainly isn't a priority.


  \newpage
  \section{Android Specific Challenges}
  \subsection{Application Lifecycle}
  As with any good mobile system, Android doesn't hesitate to end any process of an application running in background, in order to save resources. Consequently anything that should be kept alive -- network connections and \ac{POW} come to mind -- needs special treatment. This is done through foreground services. The networking part and \ac{POW} hence needed to be moved into separate services. While not difficult, it needed some research to find out how it should best be done in our case.

  \begin{center}
    \includegraphics[width=0.8 \textwidth]{images/services.pdf}
  \end{center}

  It was decided to run all services as separate threads in the same process, which simplifies communication between those services, but has the risk of the whole app crashing if there is an error in a service.

  \subsection{Deprecated Java Versions}
  Jabit uses many features from Java 7, such as \textit{try-with-resources} and \texttt{java.util.Objects}. Testing with older devices revealed that those features are only available on Android 4.4 `KitKat' and later.

  \begin{center}
    \includegraphics[width=0.6\textwidth]{images/android_version_chart_dec_2015.png}
  \end{center}

  As this would have meant a tedious search for the use of these features and their rewrite, it was decided to raise the system requirements from Android 4.0 `Ice Cream Sandwich' to 4.4 `KitKat' instead. This means that instead of 96.4\% of the devices, the app now only runs on 66.6\% of the devices that are actively using Google Play\texttrademark{}.\cite{da:dashboards}

  The Android development environment provides useful help to prevent such problems, but not if they originate from depending libraries such as Jabit.


  \newpage
  \section{Optimisations}
  \subsection{Sync Adapters}
  Android provides an API that can vastly reduce battery usage for apps that regularly update data over the internet. The system triggers synchronisation, so it can optimise its sleep modes. As it knows when the network access is done it can put the radio back to sleep immediately, unlike other kinds of network access where the system stays connected for some time in case a new connection needs to be established.

  Imagine five apps synchronising every five minutes, one after the other. In the worst case scenario the radio would need to wake up every minute, synchronize and could barely go back to sleep before the next app wants to synchronize. With the sync adapter the system triggers synchronisation for all five apps and when all are done it can put the radio back to sleep.

  Although it's not intended, synchronisation can be done without any modifications to the Bitmessage protocol. What we need is a trusted node that is always available and therefore best run on a proper server. On successful connection the protocol exchanges all new messages, so we just need to connect, wait until new messages were exchanged, and then disconnect.

  As Jabit is a Java library, it was trivial to create a server application using Spring Boot and Jabit. It turned out though that it's necessary to limit the number of connections in a Bitmessage server, therefore connections are now being severed after 12 hours or when a limit of 100 connections is reached.

  \subsection{Server Side Proof of Work}
  To reduce power consumption and possibly reduce the time to send a message, \ac{POW} can be calculated by the synchronisation server. This feature needs some changes on both server and client, and some custom extensions to the protocol.

  \subsubsection{Initial Idea}
  We first wanted the server to accept messages without \ac{POW}, which it will compute and fill in, and then relay that message. Of course this would leave the server extremely vulnerable to \ac{DOS} attacks -- an attacker could just send a bunch of messages and the server would be busy the rest of its life.

  Fortunately, Bitmessage has very secure authentication built in: every message is signed by a private key, and can be securely verified by anyone who knows the sender's address. We'll just send a message to the server that contains the actual message as content. All nonce fields are set to zero. The server checks if the sender is on a white list and then calculates the nonce and relays the complete message.

  A broadcast message would be best qualified for this task, as the client wouldn't have to be configured with a recipient address. The server is configured with a list of addresses that are allowed to request \ac{POW} and the client just needs to know the server's IP address or host name.

  \subsubsection{Acknowledging Issues}
  Unfortunately this approach has some issues. For one, sending a message would be very different using this method, requiring some major changes on the client side. Moreover, it would be impossible to generate acknowledgements.

  Acknowledgements are sent from the receiving client to notify the writer that the message was received. Think of it as a stamped addressed envelope delivered with a letter. The acknowledgement is part of the encrypted message the server can't read, so it couldn't calculate its \ac{POW}.

  Jabit doesn't support acknowledgements yet, but it would be a pity to prevent it by design.

  \subsubsection{\ac{POW} Protocol}
  Much of the planned design can be reused -- the encryption used by broadcasts, signing the messages -- but we need a wholly separate protocol, with some extra roundtrips to the server. Now the server just receives the parts needed for \ac{POW} calculation: a hash and a target value.

  When the nonce is found, it's saved on the database. The client will regularly poll for it (e.g. during synchronization cycles) until it retrieves the nonce. A great benefit of this method is the possibility to implement it as an adapter.

  \includegraphics[width=\textwidth]{images/server_pow_protocol.pdf}

  For this feature, a new command was introduced, which needs to be implemented on both server and client. It has the same structure as any Bitmessage command, and \textit{custom} in the command field. As payload it contains a signed and encrypted block, containing the following structure:

  \includegraphics[width=\textwidth]{images/custom_message.pdf}

  The custom commands for the proof of work feature are encrypted and signed, including the kind of request or response. The \textit{command} field therefore always says \texttt{ENCRYPTED}. Afterwards comes the \textit{encryption header}, including the initialisation vector (IV), the curve type (should normally be 0x2CA), and the $X$ and $Y$ coordinates of a random public key (see \ref{subsec:encryption} \nameref{subsec:encryption}{}, variable $R$).

  The payload always consists of the initial hash (the base for \ac{POW} calculation) and the kind of request or response. The data field contains the target difficulty for the \texttt{CALCULATE} request, and the calculated nonce for the \texttt{COMPLETE} response. For the \texttt{CALCULATING} response data is an empty array.

  \texttt{CALCULATE} is also used to poll the server. This has the benefit that if there is a temporary problem on the server, it will automatically start \ac{POW} calculation when the server is ready again.


  \newpage
  \section{Artefacts}

  \subsection{App}
  You can find the app's source code at \url{https://github.com/Dissem/Abit}

  \subsubsection{User Interface}
  Abit tries to imitate state of the art e-mail clients. Users of Android's stock mail client should feel right at home.

  \begin{center}
    \begin{minipage}{.71\linewidth}
      \includegraphics[width=1.0 \textwidth]{images/screenshots/inbox_and_message_N7.png}
    \end{minipage}
    \hspace{.03\linewidth}
    \begin{minipage}{.24\linewidth}
      \includegraphics[width=1.0 \textwidth]{images/screenshots/drawer_menu.png}
    \end{minipage}
  \end{center}

  A curiosity might be the `full node' switch at the bottom of the side drawer, which toggles a fully functioning Bitmessage node. As this uses a lot of traffic, the user is warned if they activate it on the mobile network. (Provided `Wi-Fi only' is set in the settings, which is the default.)

  \begin{center}
    \includegraphics[width=0.4 \textwidth]{images/screenshots/warning_dialog.png}
  \end{center}

  To both remind the user something resource hungry is going on and keep the process alive, ongoing notifications are being shown for long running tasks.

  \begin{center}
    \includegraphics[width=0.8 \textwidth]{images/screenshots/ongoing_notifications.png}
  \end{center}

  \subsubsection{Settings}

  \begin{center}
    \includegraphics[width=0.8 \textwidth]{images/screenshots/settings.png}
  \end{center}

  If \textit{Wi-Fi only} is selected, Abit will not synchronize unless it's connected to a Wi-Fi network. If you try to start a full node in this mode, you will be warned and asked if you want to continue. It is switch on by default in order to protect the user from using up his data plan.

  The \textit{trusted node} is needed for the synchronisation feature to work (receiving messages while not being a `full node').

  Synchronisation will stop trying to fetch object when the \textit{synchronization timeout} is reached. This is a safety measure so it doesn't stay connected indefinitely if there's a problem, but might keep you from quickly getting all objects when the client runs for the first time.

  If \textit{server POW} is active, all \ac{POW} will be done on the server. Please note that if there is a problem on the server, \ac{POW} won't be done at all, and a server will only do \ac{POW} for you if your identity is registered as an accepted client. In case of errors, \ac{POW} will be done if the feature is turned off and the client is restarted, which you might have to do by force.


  \subsection{Server}
  The server's source code is available at \url{https://github.com/Dissem/Jabit-Server}

  For the app to be really useful, it relies on a server component. If you don't require the \ac{POW} feature it could be any Bitmessage client that can be accessed over a known \acs{IP} address or host name, but the provided server application is very easy to deploy and, as mentioned, can do \ac{POW} for the mobile client.

  The server also provides a \acs{REST} \ac{API} and a web interface, but as they didn't have any priority they don't work properly.

  \subsection{Installation}
  You can simply run \texttt{java -jar jabit-server.jar}. By default the server will provide a web interface on port 8080 and listen for Bitmessage connections on port 8444.

  \subsubsection{Configuration}
  Five configuration files will be created if they don't exist yet. If you modify them by hand, a restart will be required to apply the changes. The files may contain Bitmessage addresses with different meanings.

  \listinginfo{}{admins.config}{Addresses in this list are allowed to administrate the server.}{}
  \listinginfo{}{clients.config}{Addresses in this list are allowed to request \ac{POW}}{}

  \vspace{5mm}
  The other three files concern the \acs{REST} \ac{API}:

  \listinginfo{}{whitelist.config}{If there are any entries, only those addresses can be requested.}{}
  \listinginfo{}{blacklist.config}{Those addresses can't be requested.}{}
  \listinginfo{}{shortlist.config}{For those addresses, only the last five broadcasts will be shown}{}

  \vspace{5mm}
  The configuration files can also be changed by a registered administrator, through sending a message with subject \textit{<command> <list>} and a list of addresses in the body, each on a separate line. The commands are

  \listinginfo{}{set}{replaces the list with the body content}{}
  \listinginfo{}{add}{adds the given addresses to the list}{}
  \listinginfo{}{remove}{removes the given addresses from the list}{}

  \vspace{5mm}
  Example:

  \listinginfo{}{Subject}{add client}{}
  \listinginfo{}{Body}{BM-2cUau5uxBYCK2Z2TVwUZnnNfYW5yyutekC\par{}
                       BM-2cXDjKPTiWzeUzqNEsfTrMpjeGDyP99WTi}{}
  \vspace{5mm}
  Adds those two addresses as clients to allow \ac{POW} requests.

  As it is a Spring Boot application, the file \texttt{application.properties} is used for all other configurations. The most important ones are:

  \attachlisting{application.properties}
  \listinginfo{1}{server.port}{On this port the server listens to HTTP requests}{}
  \listinginfo{2}{server.address}{Is probably either 0.0.0.0, where the server listens on all interfaces, or 127.0.0.1 if you want to disable the web interface or route it through a web server.}{}
  \listinginfo{4}{bitmessage.port}{On this port the server listens to incoming Bitmessage connections, e.g. from Abit users but also from random nodes.}{}
  \listinginfo{5}{bitmessage.connection.\\ttl.hours}{The maximal time a client is allowed to stay connected to the server.}{}
  \listinginfo{6}{bitmessage.connection.\\limit}{The maximum number of connections allowed for the server. If there are more connections, the oldest ones will be severed.}{}

  \newpage
  \section{Related Works}
  \subsection{E-Mail Gateways}
  A free e-mail gateway can be found at \url{https://bitmessage.ch}.

  When using an e-mail gateway, you can use your preferred e-mail client, so we can assume that daily user experience is at least as good as with the native app. Setup isn't very complicated, but still not as easy as two taps for a new identity.

  As for security, we must really trust the gateway provider, because they possess our private key. Due to the way encryption is done in Bitmessage, there is no other way to solve this problem except for using \ac{PGP} or a similar product, but this is quite troublesome to set up and use for both parties.


  \subsection{Bitseal}
  Bitseal isn't available on Google Play anymore, but its sources can be found on GitHub:\\
  \url{https://github.com/JonathanCoe/bitseal}\\
  It isn't actively being developed right now, and unfortunately the servers needed for it to work aren't currently running. It would be possible to set up a private server, but this is out of scope of this thesis.

  As it aims to be a full Bitmessage client as well, Bitseal is more directly comparable to Abit.

  \subsubsection{User Interface}
  \begin{center}
    \begin{minipage}{.3\linewidth}
      \includegraphics[width=1.0 \textwidth]{images/screenshots/bitseal_inbox.png}
    \end{minipage}
    \hspace{.03\linewidth}
    \begin{minipage}{.3\linewidth}
      \includegraphics[width=1.0 \textwidth]{images/screenshots/bitseal_message.png}
    \end{minipage}
    \hspace{.03\linewidth}
    \begin{minipage}{.3\linewidth}
      \includegraphics[width=1.0 \textwidth]{images/screenshots/bitseal_contacts_add.png}
    \end{minipage}
  \end{center}

  \subsubsection{Settings}
  \begin{center}
    \begin{minipage}{.3\linewidth}
      \includegraphics[width=1.0 \textwidth]{images/screenshots/bitseal_settings.png}
    \end{minipage}
    \hspace{.03\linewidth}
    \begin{minipage}{.3\linewidth}
      \includegraphics[width=1.0 \textwidth]{images/screenshots/bitseal_settings_export.png}
    \end{minipage}
    \hspace{.03\linewidth}
    \begin{minipage}{.3\linewidth}
      \includegraphics[width=1.0 \textwidth]{images/screenshots/bitseal_settings_system_tools.png}
    \end{minipage}
  \end{center}

  The security settings let the user enable database encryption. This adds some security if the device is compromised.

  The server settings let the user add and remove servers. Other than Abit, Bitseal supports multiple servers to be set.

  Import or export data lets the user export and import their private keys. While this is a planned feature for Abit, we prefer the wallet import format used by PyBitmessage rather than exporting the encryption and signing keys separately.

  The system tools are very useful for debugging, sporting an option to view the log and recent errors, as well as restarting the background service.

  \subsubsection{Power Usage}
  A test showed that Bitseal used about 30\% of the device's power throughout the day. In synchronization mode, Jabit uses less than 2\% over the same period. When Jabit ran as a full node however, it would have hardly lasted until noon.

TODO: more data


  \newpage
  \section{Future Work}
  \subsection{Known Bugs}
  \begin{itemize}
    \item If a user tries to import their identity as a contact, the private key is deleted.
    \item There is some issue with either requesting or sending the public key.
    \item A rare rendering error exists where different lists of messages are being drawn on top of each other.
    \item The server's user interface doesn't work.
    \item There is still no icon!
  \end{itemize}

  \subsection{Missing Features}
  \begin{itemize}
    \item Drafts aren't stored.
    \item The user interface for sending broadcasts is still missing.
    \item Identities:
      \begin{itemize}
        \item rename
        \item show as QR code
        \item share or copy to clipboard
        \item import and export
      \end{itemize}
    \item Jabit:
      \begin{itemize}
        \item It doesn't support acknowledgements yet.
        \item Stream support must be tested and probably fixed.
      \end{itemize}
  \end{itemize}



  \newpage
  \section{Conclusion}

  I'm quite proud of this app. As long as you don’t start a full node it hardly ever turns up in the battery usage statistics, its data usage is under control and I think it looks quite nice, too. There is always room for improvements, but it's time to let a broader audience test it.

  As often it wasn't the big questions that took the longest, nor the ones I expected. I've spent a lot of time exploring how to do things in a way that is both consistent with the Android ecosystem and keeps the code maintainable.

  One lesson I learned the hard way: Never take shortcuts. The first mistake was using static methods for the cryptography. Then there are some changes to the Jabit library that I didn’t create proper tests for, and I fear they are just about to come back and haunt me.
(TODO: more about this haunting…)

.

  A project like this is never quite done, it needs recurring attention. It was fun and fascinating work, but the real challenge will be finding people willing to contribute. So if you feel intrigued by this app, please contact me. Together we can make sure this project will survive.


  \newpage
  \bibliographystyle{unsrt}
  \bibliography{bibliography}

\end{document}